<!doctype html><html><head><meta charset=UTF-8><title>渐进式 Web 应用（PWA） - By Joel</title><link rel=stylesheet href=https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdn.staticfile.org/prism/1.15.0/themes/prism.min.css><link rel=stylesheet href=https://cdn.staticfile.org/KaTeX/0.10.0-rc.1/katex.min.css><link rel=stylesheet href=https://cdn.staticfile.org/prism/1.15.0/themes/prism-dark.min.css><link href=./css/chunk-vendors.4e4765ff.css rel=stylesheet></head><body><div><article id=webslides><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-right><h1 class=text-shadow>PWA - 渐进式Web应用</h1><p>by Congyu Shen</p><p><a href=https://shenjoel.github.io class="button ghost" target=_blank><i class="fa fa-github"></i> Github</a> <a href=https://shenjoel.github.io/ class="button animated fadeInUp" target=_blank><i class="fa fa-cloud-download"></i> Demo</a></p></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">1、为什么会出现 PWA</p><p style="text-shadow: none; color: black">1.1、回顾一下历史，在 2015 年之前的那段时间，作为前端开发人员，我们主要精力花在哪里，对于我来说，移动站点的性能优化是投入精力很大的一部分，例如提升首屏速度，动画的流畅度，经过一段时间的优化，性能确实有不小的提升，但是无论怎么优化，还是比 Native App 要差很多，始终无法突破移动设备上 WebView 给 Web 的枷锁，这就是我们想说的第一个问题，Web 的用户体验。</p><p style="text-shadow: none; color: black">1.2、除开用户体验问题之外，还有一个非常重要的问题，那就是用户留存。Native App 安装完毕后会在用户手机桌面上有一个入口，让用户打开 App 只需一次点击，而 Web App 在移动时代最主要的入口还是搜索引擎，用户从浏览器到站点需要经过搜索引擎，如果想访问上次同样的内容甚至还需要记住上次的搜索词，用户也可以记住 URL 并进行输入，但这些对于移动用户来说，无疑成本巨大，这就导致 Web 站点和用户之间的粘性非常脆弱。Native App 还能够通过发送通知让用户再次回到应用中来，而 Web 没有这个能力。</p><p style="text-shadow: none; color: black">1.3、Device API 的不完善。Android 和 iOS 提供了非常丰富的设备 API，Native App 只需获取用户授权就可以使用，而在 Web App 中，WebView 没有提供这样的 API，完全没法使用，如果我们开发一个需要使用 NFC 的 App，你一定不会考虑 Web，因为近场通信 API 在 Web 中还没有。虽然在近年来，W3C 已经提出了很多新的标准，但是浏览器对于 Device API 的支持仍然很不完善。</p><p style="text-shadow: none; color: black">2、在开始之前，我们先来看看一个例子</p></div></div></section><section slide class="slide bg-black-blue aligncenter" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><p><img src=./img/webVSna_uv.png> Web站点每个月的UV是Native App的<code>3 倍</code>，然而用户在Native App花费的时间却是Web的<code class=text-intro>20 倍</code></p></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">Google 在一篇名为《Why Build Progressive Web Apps》的文章中披露过这样的一组数据，Web 站点每个月的 UV 是 Native App 的 3 倍，然而用户在 Native App 花费的时间却是 Web 的 20 倍，如下图所示，这之间巨大的反差，和上面所说的三个原因息息相关。</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=content-right><h2 class=text-landing>什么是PWA</h2><ul class="build moveIn"><li>Web App Manifest</li><li>Service Worker</li><li>Web Push</li></ul></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">Google 提出 PWA 的时候，并没有给它一个准确的定义，经过这么多年的实践和总结， PWA 它不是特指某一项技术，而是应用多项技术来改善用户体验的 Web App，其核心技术包括 Web App Manifest, Service Worker, Web Push 等，而这些技术都是围绕着提升用户体验进行，这就是 PWA 的核心。</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header><div class=wrap><h3>添加到主屏幕 - 配置</h3></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="content-right build moveIn"><h3 class=content-left>Manifest:</h3><pre class=language-json><code class=language-json><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Joel's blog"</span><span class="token punctuation">,</span>                --> 应用名
  <span class="token property">"short_name"</span><span class="token operator">:</span> <span class="token string">"Blog"</span><span class="token punctuation">,</span>                 --> 应用名缩写
  <span class="token property">"icons"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span>                           --> 展示在设备屏幕在图标
      <span class="token property">"src"</span><span class="token operator">:</span> <span class="token string">"./img/192x192.png"</span><span class="token punctuation">,</span>
      <span class="token property">"sizes"</span><span class="token operator">:</span> <span class="token string">"192x192"</span><span class="token punctuation">,</span>
      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"image/png"</span><span class="token punctuation">,</span>
      <span class="token property">"purpose"</span><span class="token operator">:</span> <span class="token string">"maskable"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> 
    <span class="token punctuation">{</span>
      <span class="token property">"src"</span><span class="token operator">:</span> <span class="token string">"./img/512x512.png"</span><span class="token punctuation">,</span>
      <span class="token property">"sizes"</span><span class="token operator">:</span> <span class="token string">"512x512"</span><span class="token punctuation">,</span>
      <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"image/png"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">"start_url"</span><span class="token operator">:</span> <span class="token string">"/index.html"</span><span class="token punctuation">,</span>           --> 打开的链接
  <span class="token property">"background_color"</span><span class="token operator">:</span> <span class="token string">"#ffffff"</span><span class="token punctuation">,</span>        --> 启动的背景色
  <span class="token property">"display"</span><span class="token operator">:</span> <span class="token string">"standalone"</span><span class="token punctuation">,</span>              --> 展示方式
  <span class="token property">"theme_color"</span><span class="token operator">:</span> <span class="token string">"#2874f0"</span>              --> 主题色
  ...
<span class="token punctuation">}</span>
</code></pre></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">添加到主屏幕是现代浏览器中的一项功能，使开发人员可以轻松便捷地将自己喜欢的网络站点的快捷方式添加到主屏幕中，用户随后可以通过单击访问它。而刚才提到的 Web App Manifest，是一份web app的清单，用来配置添加主屏的入口文件，存放在要目录当中。</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header><div class=wrap><h3>添加到主屏幕 - 安装</h3><p><code>&lt;link rel=&quot;manifest&quot; href=&quot;./manifest.json&quot; /&gt;</code></p></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><img src=./img/a2hs-install.png class="size-70 alignleft"> <img src=./img/a2hs-install-modal.png class="size-20 alignright"></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">配置好之后在主文档中引入文件，在浏览器地址栏会出现小图标，或是菜单项里会有安装选项，点击之后会有一个安装提示，确认后主屏幕上会新增一个配置好的图标，也是当前web app的入口，实际的开发中自己去实现安装的UI，通过API去完成安装，那么到这里主屏添加的功能就已经实现了。</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header class=text-intor><div class=wrap><h3>添加到主屏幕 - <a href=https://shenjoel.github.io/ target=_blank><i class="fa fa-link"></i></a>清单检查</h3></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><img src=./img/a2hs-install-checklist.png class="size-80 alignleft"></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">清单配置项可以通过Chrome控制台查看是否正确</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header><div class=wrap><h3>Manifest 属性值兼容性</h3></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div style="width: 1200px; height: 700px; overflow: auto;"><img src=./img/Web-app-manifests-MDN.png></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">不同的系统和浏览器的兼容情况也是大不相同，移动端Android Chrome的支持是最完整的，在桌面端Chrome和Edge也是支持比较好的，当然在移动端的体验是最好，甚至提供了与原生APP一至的在，打开应用时的入场动效，单独的浏览容器，那我们来看下实际的交互场景是怎样的（转Demo）</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header><div class=wrap><h3>Service Worker</h3></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="bg-white shadow"><ul class="flexblock reasons"><li><h2>代理层</h2><p>Service Worker 是浏览器和网络之间的虚拟代理</p></li><li><h2>独立工作线程</h2><p>不同于页面主线程，独立运行在另一个工作线程上，它无权访问 DOM 结构</p></li></ul></div><div class=embed><pre class="lang-mermaid no-style">graph TD
	UA --> service_worker
	service_worker --> UA
	service_worker --> Server
	Server --> service_worker
</pre></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">Service Worker 是浏览器和网络之间的虚拟代理</p><p style="text-shadow: none; color: black">不同于页面主线程，独立运行在另一个工作线程上，它无权访问 DOM 结构</p><p style="text-shadow: none; color: black">早在 2014 年 5 月 W3C 就提出了 Service Worker 草案，用来进行 Web 资源和请求的持久离线缓存。Service Worker 的来历可以从两个方面来介绍。</p></div></div></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header><div class=wrap><h3>Service Worker</h3></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class="bg-white shadow"><ul class="flexblock reasons"><li><h2>释放主线程的性能压力</h2><p>将复杂的耗时的工作脱离主线程执行，释放在主线程的性能耗时。</p></li><li><h2>持久离线缓存能力</h2><p>可以通过自身的生命周期特性保证复杂的工作只处理一次，并持久缓存处理结果，直到修改了 Service Worker 的内在的处理逻辑。</p></li></ul></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">一方面，浏览器中的 JavaScript 是运行在一个单一主线程上的，在同一时间内只能做一件事情。随着 Web 业务不断复杂，在 JavaScript 中的代码逻辑中往往会出现很多耗资源、耗时间的复杂运算过程。这些过程导致的性能问题在 Web App 日益增长的复杂化过程中更加凸显出来。所以 W3C 提出了 Web Worker API 来专门解放主线程，Web Worker 是脱离在主线程之外的工作线程，开发者可以将一些复杂的耗时的工作放在 Web Worker 中进行，工作完成后通过 postMessage 告诉主线程工作的结果，而主线程通过 onmessage 得到 Web Worker 的结果反馈，从而释放了主线程的性能压力。</p><p style="text-shadow: none; color: black">代码执行性能问题好像是解决了，但 Web Worker 是临时存在的，每次做的事情的结果不能被持久存下来，如果下次访问 Web App 同样的复杂工作还是需要被 Web Worker 重新处理一遍，这同样是一件消耗资源的事情，只不过不是在主线程消耗罢了。那能不能有一个 Worker 线程是一直可以持久存在的，并且随时准备接受主线程的命令呢？基于这样的需求 W3C 推出了最初版本的 Service Worker，Service Worker 在 Web Worker 的基础上加上了持久离线缓存能力，可以通过自身的生命周期特性保证复杂的工作只处理一次，并持久缓存处理结果，直到修改了 Service Worker 的内在的处理逻辑。</p><p style="text-shadow: none; color: black">让我们简单了解一下 Service Worker 生命周期的工作原理</p></div></div></section><section slide class="slide fullscreen bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=grid><div class=column><img style="display: block;" src=./img/sw-lifecycle.png></div><div class=column><h2>执行过程</h2><p>在主线程成功注册 Service Worker 之后，开始下载并解析执行 Service Worker 文件，执行过程中开始安装 Service Worker，在此过程中会触发 worker 线程的 install 事件。</p><p>如果 install 事件回调成功执行（在 install 回调中通常会做一些缓存读写的工作，可能会存在失败的情况），则开始激活 Service Worker，在此过程中会触发 worker 线程的 - activate 事件，如果 install 事件回调执行失败，则生命周期进入 Error 终结状态，终止生命周期。</p><p>完成激活之后，Service Worker 就能够控制作用域下的页面的资源请求，可以监听 fetch 事件。</p><p>如果在激活后 Service Worker 被 unregister 或者有新的 Service Worker 版本更新，则当前 Service Worker 生命周期完结，进入 Terminated 终结状态。</p></div></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">通过 Service Worker 让 PWA...?</p></div></div><footer class="build fadeInRight"><div class=wrap><h4><code>通过 Service Worker 让 PWA...?</code></h4></div></footer></section><section slide class="slide bg-black-blue" image="https://source.unsplash.com/C1HhAQrbykQ/ .dark"><header class=alignright><div class=wrap><h3>通过 Service Worker 让 PWA - 缓存资源</h3></div></header><span class="background dark" style="background-image:url('https://source.unsplash.com/C1HhAQrbykQ/')"></span><div class=wrap wrap=true><div class=grid><div class=column><h4>在安装过程中缓存资源</h4><div class=embed><pre class="lang-mermaid no-style">graph TD
	register --> install -- open cache --> installed
</pre></div></div><div class=column><pre class=language-js><code class=language-js><span class="token comment">// 缓存的key</span>
<span class="token keyword">const</span> cacheName <span class="token operator">=</span> <span class="token string">'joelblog-sorce-v0.0.2'</span><span class="token punctuation">;</span>

<span class="token comment">// 保存到本地cache的文件路径</span>
<span class="token keyword">const</span> filesToCache <span class="token operator">=</span> <span class="token punctuation">[</span>
	<span class="token string">'/'</span><span class="token punctuation">,</span>
	<span class="token string">'/index.html'</span><span class="token punctuation">,</span>
	<span class="token string">'/css/m.min.css'</span><span class="token punctuation">,</span>
	<span class="token string">'/js/index.js'</span><span class="token punctuation">,</span>
	<span class="token string">'/img/webper.png'</span><span class="token punctuation">,</span>
	<span class="token string">'/img/180x180.png'</span><span class="token punctuation">,</span>
	<span class="token string">'/img/192x192.png'</span><span class="token punctuation">,</span>
	<span class="token string">'/img/512x512.png'</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 安装</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[ServiceWorker] Install'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
		caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">cache</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[ServiceWorker] Caching app shell'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>filesToCache<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 拦截请求</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[Service Worker] Fetch'</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
	e<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
		caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">response</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
			<span class="token keyword">return</span> response <span class="token operator">||</span> <span class="token function">fetch</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></div></div><div class=speaker-note><div class=wrap><p style="text-shadow: none; color: black">可以看到, 我们在 install 的监听函数中，利用caches api 缓存资源列表. 接下来当用户再次访问时，fetch 事件会拦截当前页面请求</p></div></div></section></article></div><script src=https://cdn.staticfile.org/mermaid/8.5.2/mermaid.min.js></script><script>mermaid.startOnLoad = false;</script><script>window.pluginsOptions = {}



    window.webslidesOptions = {}


document.addEventListener('DOMContentLoaded', () => {
    let isPrintMode = false;
    if(~location.search.indexOf('print-pdf')){
        isPrintMode = true;
        WebSlides.registerPlugin('scroll', function(){});
    }
    const wsOptions = {
        loop: false
    };
    if(window.webslidesOptions){
        for (let i in webslidesOptions){
            if(webslidesOptions.hasOwnProperty(i)){
                wsOptions[i] = webslidesOptions[i];
            }
        }
    }
    const ws = new WebSlides(wsOptions)

    window.wsInstance = ws;
    if(isPrintMode){
        ws.slides.forEach(s=>s.show())
    }
}, false)</script><script src=./js/chunk-vendors.js></script><script src=./js/index.js></script></body></html>